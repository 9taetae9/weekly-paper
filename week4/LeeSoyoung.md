# 🇶 Spring Framework가 탄생하게 된 배경과 이를 통해 해결하고자 했던 문제점에 대해 설명하세요.
# ✔️ Spring 이전에 "EJB"가 있었다

## EJB란?

- Enterprise JavaBean
- 자바 플랫폼을 기반으로 한 서버 사이드 컴포넌트 모델
- 엔터프라이즈 애플리케이션 개발을 단순화하고 표준화된 방법으로 비즈니스 로직을 구현할 수 있도록 설계됨

1990년대 후반- 2000년대 초반까지 기업 애플리케이션의 복잡성이 급격하게 증가하며,
대규모 트랜잭션 처리, 분산 시스템, 보안 요구사항 등 개발자들은 복잡한 요구사항들을 관리해야 했다.

이를 지원하기 위해 비즈니스 로직을 캡슐화하는 표준화된 컴포넌트 모델을 제공하여 일관된 개발 방식을 지원하는 EJB가 자바 EE(Enterprise Edition)의 핵심 컴포넌트로 도입되었다.

## EJB의 주요 목적

- **표준화된 컴포넌트 모델 제공:** 일관된 방식으로 비즈니스 로직을 구현할 수 있도록 표준화된 컴포넌트 모델을 제공.
- **인프라 서비스 자동화:** 트랜잭션 관리, 보안, 원격 접근 등 엔터프라이즈 애플리케이션에 필수적인 인프라 서비스를 자동으로 처리하여 개발자가 비즈니스 로직에 집중할 수 있게 지원.
- **확장성 및 분산 처리 지원:** 분산 환경에서의 애플리케이션 확장성과 성능을 지원하여 대규모 트랜잭션 처리를 용이하게 함.


# 🔎 Spring의 등장 배경 

## EJB의 한계
EJB는 강력한 기능을 제공했지만 몇 가지 단점이 있었다.

**1. 테스트의 어려움**
분산 애플리케이션은 단일 JVM에서 실행되는 애플리케이션보다 항상 테스트하기가 더 어렵다.
원격 인터페이스를 사용하든 로컬 인터페이스를 사용하든 EJB 애플리케이션은
컨테이너 내에서만 실행할 수 있어 컨테이너 서비스에 대한 의존성이 높아 단위 테스트가 어렵다.

**2. 복잡한 개발 과정**
```Home Interface: EJB 인스턴스 생성/제거 담당, Remote Interface: 클라이언트가 호출할 메서드 정의, Bean Class: 실제 비즈니스 로직을 수행하는 구현체``` 등 여러 인터페이스를 구현해야 했고, XML 설정 파일을 필수적으로 작성해야 했다.
이로 인해 개발 속도가 느려지고, XML 설정의 유지보수도 어려웠다.

**3. 무거운 컨테이너**
> EJB를 사용하면 애플리케이션 작성을 편하게 할 수 있다. 로우레벨의 트랜잭션이나 상태 관리, 멀티스레딩, 리소스 풀링과 같은 복잡한 로우레벨의 API 따위를 이해하지 못하더라도 아무런 문제 없이 애플리케이션을 개발할 수 있다.

EJB의 목표는 편리한 애플리케이션 개발이었지만, 기술에 대해 과도한 욕심을 부린 탓에 불필요하게 무거웠다.
EJB 객체의 생성, 제거, 트랜잭션 관리, 보안 설정 등을 자동으로 처리하지만, 이로 인해 불필요한 메모리 사용, 오버헤드가 발생했다.

**4. 의존성 강한 설계**
EJB는 JNDI(Java Naming and Directory Interface)를 통해 객체를 찾는 구조로 특정 서버 환경과 밀접하게 결합된 구조이다.
이는 코드의 결합도를 증가시켜 새로운 기능을 추가하거나 서버를 변경하는 것이 어렵고, 유지보수를 어렵게 만들었다.

이로 인해 배포도 어렵고, 실행도 어렵고, 여러모로 비효율적인 면이 있었고
해결해야 할 문제로 남게 되었다.

## Spring의 등장 계기

이러한 EJB의 단점을 해결하기 위해 2003년 로드 존슨이 "Expert One-on-One J2EE Design and Development"라는 책을 출간하며 Spring Framework를 발표했다.

![](https://velog.velcdn.com/images/soo7132/post/c8d2ff64-076d-40e5-a398-59ee9296b5b6/image.png)

책 초반부에서 로드 존슨은 EJB는 다음과 같은 근거로 EJB의 문제점을 지적한다.
1. 테스트하기 어렵다
2. 배포도 어렵다.
3. Remote Interface를 사용하는 EJB는 설계도 어렵다.

EJB를 대체할 방안을 3만 라인 정도의 샘플 코드를 예시로 들며 설명하는데 여기에서 사용된 예시용 프레임워크가 매우 흥미로웠던 개발자들이 로드 존슨을 설득하여 오픈소스 프로젝트를 시작하게 됐다고 한다. 그렇게 우리에게 익숙한 스프링 프레임워크가 등장했다.

# ✨ Spring

## Spring의 정의: 스프링 프레임워크란?
그렇다면 스프링은 뭔데 EJB의 문제점을 해결했을까? 이 정의에 스프링의 특징이 다 들어가 있다.

> 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크

하나하나 뜯어보자.

**1. 오픈 소스**
- 앞서 등장 계기에서 설명했듯 오픈 소스 프로젝트로 발전된 Spring은 Apache 2.0 라이선스를 기반으로 한 오픈소스 프레임워크이다.
- 무료이며, 전 세계 개발자들이 지속적으로 발전에 참여하고, 커뮤니티도 활발하다.

**2. 경량급**
- 기존 EJB의 무겁고 복잡한 구조를 개선했다.
- 특정 컨테이너가 반드시 필요했던 EJB와 달리 POJO(Plain Old Java Obejct) 기반으로 설계된 스프링은 Tomcat, Jetty, Undertow 같은 가벼운 웹 서버에서도 실행 가능하다.
- 즉, 개발자가 원하는 환경에서 유연하게 실행될 수 있다.
- 또한 Java 코드와 어노테이션 기반의 설정을 지원하며 XML 설정도 최소화되어 가볍고 단순하다.

**3. 애플리케이션 프레임워크**
- 애플리케이션 프레임워크: 특정 계층이나, 기술, 업무 분야에 국한되지 않고 애츨리케이션의 전 영역을 포괄하는 범용적인 프레임워크
- 개발자가 비즈니스 로직만 작성하면 나머지 기능(트랜잭션, 보안, 객체 관리 등)은 프레임워크가 알아서 처리한다는 게 포인트이다.
- EJB, Spring 모두 애플리케이션 프레임워크지만 EJB보다 간단하고 유연하다.

**4. 편한 자바 엔터프라이즈 개발**
- 스프링의 목표는 여러 가지 핵심 기능으로 복잡한 개발을 간단하게 해주는 것이다.

## Spring의 핵심 개념
EJB의 문제를 해결하고 편하게 자바 엔터프라이즈를 개발하는 것을 목표로 스프링은 다음과 같은 기능을 가지고 있다.
 
### 경량 컨테이너
스프링이 경량급 애플리케이션 프레임워크인 이유는,
경량 컨테이너를 사용하여 애플리케이션 내 흐름을 관리하고, 불필요한 무거운 서버나 복잡한 설정 없이 필요한 기능만 제공하기 때문이다.

- 객체의 라이프사이클 관리
객체의 생명주기를 개발자가 아니라 컨테이너에서 관리한다.
- 의존성 주입 처리
각 객체에서 직접 필요한 의존성을 생성하거나 찾는 것이 아니라 컨테이너가 객체에 필요한 의존성을 주입한다.
- 설정 기반 동작
컨테이너는 설정 파일+어노테이션에 기반해서 객체(스프링 빈)을 생성한다.

기존의 무거운 EJB의 컨테이너와 달리 필요한 기능만 제공하여 애플리케이션의 성능을 최적화화고, 
Spring은 내장형 서버(예: Tomcat, Jetty 등)를 사용하여 별도의 복잡한 애플리케이션 서버 설정 없이 애플리케이션을 실행 및 배포할 수 있다.

### 제어의 역전(Inversion of Control, IoC)
경량 컨테이너의 포인트는 "객체 생명주기 관리의 주체"이다.
제어의 역전은 경량 컨테이너의 기반이 되는 원칙이다. 

전통적인 프로그래밍 방식에서는 개발자가 애플리케이션의 흐름을 제어했다.
개발자가 언제 어느 객체를 생성하고 폐기할지 어떤 흐름으로 실행할지를 모두 정했다.
이는 개발자가 객체의 생명주기를 직접 생각해야 한다는 뜻이다.

그러나 외부 프레임워크나 컨테이너가 제어 흐름을 제어하게 한다면
개발자는 객체의 생성, 초기화, 소멸, 그리고 의존성 주입을 신경 쓸 필요 없다.

이처럼 애플리케이션 흐름을 제어하는 주체가 '개발자'에서 '프레임워크'로 역전되어
**개발자는 객체의 생명주기를 세세하게 신경쓰지 않고
오직 비즈니스 로직에만 집중할 수 있게 되었다.**


### 의존성 주입(Dependency Injection, DI)
IoC를 구현하는 방법에는 의존성 주입(DI)와 의존성검색(DL) 등이 있는데 스프링은 기본적으로 DI 방식을 사용한다.

**의존성 주입은 객체 간의 의존성을 직접 설정하는 대신, 필요한 객체를 외부에서 주입하는 기술이다.**
즉, 클래스 간의 의존관계를 Bean 설정에 기반하여 컨테이너가 자동으로 연결해주는 방식이다.

의존성을 주입받는 방법은 크게 3가지가 있다.
- 생성자 주입
- 세터 주입
- 필드 주입

의존성 주입의 장점은 다음과 같다.
- **결합도 감소:** 객체 간의 직접적인 의존성이 줄어든다.
- **유연성 향상:** 의존성을 쉽게 교체하거나 확장할 수 있다.
- **테스트 용이성:** Mock 객체를 주입하여 단위 테스트를 수행할 수 있다.
- **재사용성 증가:** 모듈 간의 독립성이 높아져 재사용이 용이하다.


### 관점 지향 프로그래밍(Aspect-Oriented Programming, AOP)
관점 지향 프로그래밍은 **프로그램을 구성하는 핵심 비즈니스 로직(주된 관심사)**과 **공통적으로 필요한 부가 기능(횡단 관심사)**을 분리하여 모듈화하는 프로그래밍 패러다임이다.

**횡단 관심사**
애플리케이션의 여러 모듈이나 컴포넌트에 걸쳐 공통적으로 적용되는 기능으로
로깅, 보안, 트랜잭션 관리, 예외 처리가 대표적인 예시이다.
다음 그림과 같이 여러 모듈에 횡단 형태로 포함된다는 의미에서 붙여진 이름이다.
![](https://velog.velcdn.com/images/soo7132/post/67e9c285-11f6-4600-bef2-77d761ea9ccc/image.png)

공통 모듈은 필요한 시점에 비즈니스 로직에 삽입되어 실행되어
코드의 중복을 줄이고, 유지보수를 용이하게 한다.


# 정리: EJB와 Spring 비교
스프링의 어떤 점이 좋아 스프링을 쓰는지 알아보았다.

## Spring vs EJB
- 경량화: Spring은 필요한 기능만 제공하고, 복잡한 설정 없이 가볍게 애플리케이션을 구성할 수 있도록 한다. EJB는 무거운 컨테이너로, 성능에 부담을 주고 복잡한 설정을 요구했다.
- 배포 용이성: Spring은 내장 서버를 지원하여, 별도의 복잡한 애플리케이션 서버 설정 없이 쉽게 배포할 수 있다. EJB는 별도의 애플리케이션 서버가 필요해 배포가 복잡했다.
- 의존성 주입(DI): Spring은 IoC(제어의 역전) 원칙을 적용하여 객체 관리와 의존성 주입을 자동으로 처리한다. EJB는 이러한 기능을 제공하지 않았고, 객체 생성과 의존성 관리가 비효율적이었다.
- 관점 지향 프로그래밍(AOP): Spring은 AOP를 통해 공통 기능을 비즈니스 로직에서 분리하여 관리한다. 

| **특징**             | **Spring**                                            | **EJB (Enterprise JavaBeans)**                                 |
|----------------------|-------------------------------------------------------|---------------------------------------------------------------|
| **컨테이너**          | 경량 컨테이너 (Spring IoC 컨테이너)                   | 무거운 컨테이너 (EJB 컨테이너)                                 |
| **객체 관리**         | 객체의 생명주기와 의존성 관리가 Spring 컨테이너에서 자동으로 처리 | 객체의 생명주기 관리가 클라이언트 요청에 따라 EJB 컨테이너에서 처리, 설정 복잡도 높음 |
| **설정**              | **XML 설정** 또는 **어노테이션** 기반으로 설정 가능  | 대부분 **XML 설정**이 필요하고 설정이 복잡함                  |
| **배포**              | 내장 서버 지원 (예: Spring Boot로 Tomcat, Jetty 등 사용) |  EJB 컨테이너가 반드시 필요      |
| **의존성 관리**       | **의존성 주입(DI)**을 통해 객체 간 의존성 관리         | **EJB 컨테이너**에서 객체 생성 및 의존성 관리                  |
| **성능**              | 경량화된 설계로 성능 최적화 가능                       | 무겁고 복잡하여 성능이 낮을 수 있음                           |
| **트랜잭션 관리**     | AOP를 사용하여 트랜잭션 관리 가능                      | EJB 내장 트랜잭션 관리 기능 사용                              |
| **확장성**            | 애플리케이션이 쉽게 확장 가능                          | 유지보수와 확장 모두 어려움    |
| **테스트 용이성**     | Mock 객체 활용 가능하고 단위 테스트가 쉬움          | 테스트가 어렵고, EJB 컨테이너에 의존                          |
| **공통 관심사 처리**  | AOP로 공통 기능(로깅, 보안, 트랜잭션 등)을 분리      | 복잡한 설정이 필요       |


# 📋 참고자료
> 추천
[[스프링] 스프링이란 무엇인가?](https://12bme.tistory.com/157?category=682904) : 로드 존슨의 책을 가장 잘 정리한 글이라고 본다. 강추!
[[Spring] Spring vs EJB ](https://yummy0102.tistory.com/550) :Spring뿐만 아니라 EJB의 특징에 대해 가장 자세히 기술한 글이다.

> "스프링 5 마스터 2/e", 랑가 라오 카라남, 에이콘출판사, 2020

# 🇶 프레임워크와 라이브러리의 차이점을 제어 흐름의 주체와 사용 방식을 중심으로 설명하고, Spring Framework와 일반 Java 라이브러리를 예시로 들어 설명하세요.

# 프레임워크 vs 라이브러리
**🔁프레임워크**
새로운 애플리케이션을 보다 효율적으로 개발할 수 있도록 하는 재사용 가능한 소프트웨어 구성 요소의 모음이다.

소프트웨어 프레임워크에는 특정 소프트웨어 표준 및 프로토콜을 기반으로 재사용 가능한 코드 모듈이 포함되어 있다. 따라서 새로운 애플리케이션을 표준화된 방식으로 개발할 수 있다.

---
**📚라이브러리**
미리 기능들(책)을 필요할 때마다 기록된 코드를 빼와서 재사용할 수 있도록 클래스나 함수가 모여있는 집합소(도서관)이다.

개발자가 모든 기능을 매번 직접 개발하기엔 생산성이 떨어지니 라이브러리를 사용한다.

---
프레임워크와 라이브러리는 모두 소프트웨어 개발에서 반복적인 작업을 없애 코드 중복을 줄여주는 도구이지만, "제어 흐름의 주체와 사용 방식"에 대한 차이가 있다.

## 제어 흐름의 주체의 차이
**🔁프레임워크**
제어 흐름의 주체가 프레임워크 자체이다. 
개발자는 프레임워크에서 제공하는 규칙과 구조에 맞춰 코드를 작성하고, 그 과정에서 프레임워크가 필요한 시점에 개발자의 코드를 호출한다. 
즉, 프레임워크가 제어 흐름을 주도하고, 개발자는 그 흐름에 맞춰 코드를 삽입하는 형태이다.

**📚라이브러리**
라이브러리는 개발자가 호출하는 도구이다. 
개발자가 필요할 때 라이브러리의 함수나 메서드를 호출하여 기능을 사용한다. 
즉, 제어 흐름은 개발자에게 있습니다. 개발자가 라이브러리를 호출하면 그때 라이브러리가 수행하고, 다시 제어권이 개발자에게 돌아간다.

## 사용 방식의 차이
**🔁프레임워크**
프레임워크는 특정한 구조와 패턴을 요구한다. 프레임워크는 개발자가 코드를 작성할 때 이를 특정한 방식으로 구성하도록 유도한다. 
예를 들어, Spring Framework는 MVC(Model-View-Controller) 패턴을 따르며, 개발자는 이 패턴에 맞는 구조로 애플리케이션을 작성해야 한다.

**📚라이브러리**
라이브러리는 보통 단독으로 사용되며, 개발자가 자신이 원하는 기능만 선택적으로 사용할 수 있다. 
예를 들어, Java에서 다양한 유틸리티를 제공하는 라이브러리들이 있을 때, 그 중 필요한 부분만 사용하고 나머지는 무시할 수 있다.

## 예시: Spring Framework vs Java Library

**Spring Framework**
저번 글에서 스프링의 특징을 다루었고, 그 중 "제어의 역전"으로 스프링이 애플리케이션의 흐름을 관리한다는 것을 배웠다.
참고: [Spring Framework의 등장 배경과 특징](https://velog.io/@soo7132/Spring-WP-4-1.-Spring-Framework%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD%EA%B3%BC-%ED%95%B5%EC%8B%AC-%EC%B2%A0%ED%95%99-feat.-EJB)

객체의 생명 주기는 개발자가 아니라 스프링 프레임워크가 관리하며 제어의 주도권은 스프링 프레임워크가 가진다.

또한 MVC 패턴처럼 컨트롤러-서비스-레포지토리 아키텍처 등 프레임워크에 맞는 구조에 개발자가 따라야 한다.

**Java Libirary**
자바 코드에서 어떤 특정한 라이브러리를 쓰고 싶다면 아래처럼 import를 해야한다.
이러한 코드는 개발자가 직접 작성하는 것으로 제어의 주도권이 개발자에게 있다.

라이브러리란 개발자가 전체적인 규칙을 따르는 것이 아니라 개발자가 원하는 부분만 가져오는 것이다.

```import java.util.ArrayList;```
```import java.util.List;```

# 요약
라이브러리는 제어 흐름이 개발자에게 있으며, 필요한 기능을 선택적으로 호출하여 사용한다.
프레임워크는 제어 흐름이 프레임워크에게 있으며, 개발자는 그 흐름에 맞춰 코드를 작성한다.
