# Spring Framework의 탄생 배경 및 해결하고자 한 문제점

Spring Framework는 2002년 로드 존슨이 제시한 개념을 바탕으로, J2EE 환경의 복잡성과 EJB 중심 아키텍처의 한계를 극복하기 위해 탄생

---

## 1. 탄생 배경

### 1.1 J2EE와 EJB의 복잡성 문제
- **J2EE 환경의 복잡성**  
  - Servlet, JSP, JDBC 등 다양한 스펙이 혼재되어 있어 통합 및 설정이 매우 복잡함
- **EJB의 한계**  
  - **과도한 설정 및 보일러플레이트 코드**  
    - 단순 비즈니스 로직 구현에도 Home/Remote 인터페이스, XML 설정 파일, 배포 서술자 등이 필요, 복잡함을 증가시키는 lifecycle callback 메서드
  - **테스트의 어려움**  
    - EJB 컴포넌트는 컨테이너 외부에서 테스트하기 어려워 통합 테스트 환경 구축에 많은 리소스가 필요함
  - **강한 결합도**  
    - 객체 간 의존성이 하드코딩되어 유연성이 떨어지고 코드 재사용성이 저하됨

### 1.2 객체지향 원칙과 POJO의 필요성
- **객체지향 설계 원칙 적용의 어려움**  
  - OCP(개방-폐쇄 원칙)와 DIP(의존관계 역전 원칙)를 기존 EJB 기반 시스템에 적용하는 데 많은 작업이 필요함
- **POJO(Plain Old Java Object) 기반 개발**  
  - '코드에 프레임워크가 침투하지 않는다'는 특성으로 순수 자바 객체 유지 가능
  - EJB에 종속되어 있는 무거운 객체 사용 없이 유지보수와 테스트가 용이한 애플리케이션을 구현할 수 있음
    - EJB 3.0에서 POJO 기반 개선 시도했으나 이미 Spring 생태계가 확립되었음

### 1.3 개발 생산성 및 유지보수 문제
- **높은 개발 비용**  
  - 복잡한 설정 파일과 강한 모듈 간 결합으로 인해 개발 기간이 길어지고, 변경 시 전체 시스템에 영향을 미침
- **유연한 확장 요구**  
  - 단위 테스트와 모듈화된 코드, 쉽게 교체 가능한 컴포넌트를 통한 생산성 향상이 필요함

---

## 2. Spring이 해결하고자 한 문제점 및 도입된 기능

### 2.1 경량 컨테이너와 DI/IoC
- **의존성 주입(Dependency Injection, DI)**  
  - 객체 생성과 관리(Bean)를 Spring 컨테이너가 담당하여, 코드 수정 없이도 새로운 구현체를 주입할 수 있음

- **제어의 역전(Inversion of Control, IoC)**  
  - 애플리케이션의 흐름 제어를 프레임워크에 맡겨 결합도를 낮추고 유연성을 높임

### 2.2 POJO 기반 개발
- **비침투적 설계**  
  - Spring은 특정 인터페이스 상속이나 복잡한 규격에 의존하지 않고, 일반 자바 클래스로 비즈니스 로직을 구현할 수 있게 지원함
  - **예시**
    ```java
    @Component
    public class UserService {
        @Autowired
        private UserRepository repository;  // 인터페이스에 의존
    }
    ```
- **테스트와 확장의 용이성**  
  - POJO를 사용하면 Mock 객체를 활용한 단위 테스트가 쉬워지고, 기능 확장이 원활함

### 2.3 모듈화 및 선언적 트랜잭션 관리
- **모듈화**  
  - Spring은 20개 이상의 독립 모듈로 구성(6개의 주요 카테고리: Core, Data Access, Web, AOP, Messaging, Test)되어있고, 필요한 기능만 선택적으로 사용할 수 있어 경량화된 애플리케이션 구성이 가능함

- **선언적 트랜잭션 관리**  
  - XML 또는 어노테이션 기반의 설정으로, 비즈니스 로직과 인프라를 분리해 복잡한 트랜잭션 코드를 간소화함

---
**요약**  
- **배경:** J2EE의 복잡성과 EJB의 한계  
- **해결:** DI/IoC, POJO, 모듈화, 선언적 트랜잭션 관리  
- **결과:** 유연하고 생산적인 엔터프라이즈 애플리케이션 개발 환경 제공


# 프레임워크와 라이브러리의 차이점

**프레임워크**  
- **제어 흐름**  
  - 프레임워크는 애플리케이션 전체의 제어 흐름을 주도  
  - 개발자가 작성한 코드를 프레임워크가 필요할 때 호출
- **사용 방식**  
  - 개발자는 프레임워크가 정한 규칙이나 구조(예: DI, AOP 등)에 맞춰 코드를 작성
  - 애플리케이션의 라이프사이클 관리, 객체 생성, 의존성 주입 등의 작업을 프레임워크가 담당
- **예시**  
  - **Spring Framework**  
    - Spring은 IoC 컨테이너를 통해 Bean의 생성 및 관리를 담당하고, 필요할 때 개발자가 작성한 비즈니스 로직을 호출함

**라이브러리**  
- **제어 흐름**  
  - 라이브러리는 기능을 제공하는 도구일 뿐이며, 제어 흐름은 전적으로 개발자가 관리함
  - 개발자가 필요할 때 해당 함수나 클래스를 직접 호출함
- **사용 방식**  
  - 개발자가 애플리케이션의 흐름을 직접 구성하며, 라이브러리는 그 흐름 내에서 특정 기능을 수행
- **예시**  
  - **일반 Java 라이브러리 (예: java.lang )**  
    - 이러한 라이브러리들은 문자열 처리나 컬렉션 확장 같은 기능을 제공하며, 개발자가 필요할 때 직접 호출하여 사용


