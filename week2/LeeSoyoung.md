
# 🔎 주제
> 객체지향 프로그래밍에서 '단일 책임 원칙(SRP)'과 '개방-폐쇄 원칙(OCP)'에 대해 설명하고, 각각의 원칙을 적용한 코드 예시를 들어주세요.

객체 지향 프로그래밍에는 **'SOLID'** 원칙이 있다.
Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, Dependency Inversion 이 5가지 원칙을 말하는데 오늘은 그 중 두 개의 원칙에 대해 다룬다.


# ✅ 단일 책임 원칙(SRP)
**단일 책임 원칙Single Responsibility, SRP**는 **클래스는 하나의 책임만 가져야 한다**는 원칙이다.

- 책임: 클래스가 처리해야 하는 하나의 변경 이유
쉽게는 클래스가 담당해서 처리해야 하는 하나의 "일"이라고 볼 수 있다. 클래스는 자신이 맡은 특정한 "일"만 처리해야 한다. 하나의 클래스는 단 한가지의 이유로만 변경되어야 한다.

하나의 클래스가 맡는 책임이 많아질수록, 클래스는 복잡해지고 수정과 유지보수가 어려워진다. 한 일을 변경했다가 다른 일에 영향을 끼칠 수 있기 때문이다.

## ☕ 예시 
일상생활을 예시로 생각해보자.

> 카페에서 직원이 한 명만 있다.
이 직원은 커피를 제조하고, 계산도 하고, 청소도 한다.

한 명의 직원이 여러 업무를 맡고 있다.
만약 커피 제조 레시피가 바뀌고, 포스기 시스템도 바뀌고, 청소 구역도 바뀐다면 적응하기 쉽지 않을 것이다.

- ```직원=클래스```, ```업무=책임```, ```레시피, 시스템```, ```구역 바뀜=변경 이유```, ```적응=클래스 수정/변경```이라고 생각해보자.

> 카페에 직원이 늘었다.
바리스타는 커피를 만들고, 캐셔는 계산을 하고, 청소부는 청소를 한다.

커피 메뉴가 바뀌어도 캐셔와 청소부는 신경쓰지 않는다.
포스기 시스템이 바뀌어도 바리스타와 청소부는 신경쓰지 않는다.
자신의 책임이 아니기 때문이다.

업무 분장(=책임을 나누는 것)이 효율적이고 안정적인 운영을 위한 해답이다.

## 🖥️ 예시 코드

- 단일 책임 원칙을 지키지 않은 경우
  
커피 제조와 주문 받기, 두 가지 일을 하고 있다.

이 클래스는 음료 레시피가 바뀌거나, 또는 현금만 받는 등 결제 시스템이 바뀌는 등 두 가지의 이유로 변경될 수 있다.
```
public class Cafe {

	// 커피 제조
	public Coffee makeCoffee(String menu) {
    	if(메뉴=="아메리카노") {
        	원두 추출;
            물 따르기;
        } else if(메뉴=="카페라떼") {
        	원두 추출;
            우유 스팀하기;
        }
        ...
    }
    
    // 주문 받기
    public void createOrder(String menu) {
    	포스기에서 메뉴 선택;
     	...
    }
    
}
```

- 단일 책임 원칙을 지킨 경우
  
바리스타는 커피 제조를, 캐셔는 결제를 처리한다.
```
public class Barista {
	// 커피 제조
	public Coffee makeCoffee(String menu) {
    	if(메뉴=="아메리카노") {
        	원두 추출;
            물 따르기;
        } else if(메뉴=="카페라떼") {
        	원두 추출;
            우유 스팀하기;
        }
        ...
    }
}

public class Casher {
	// 주문 받기
    public void createOrder(String menu) {
    	포스기에서 메뉴 선택;
     	...
    }
}
```

각각의 클래스가 명확하게 자신만의 책임을 가지므로 테스트, 수정, 유지보수가 쉬우며 독립적이므로 재사용도 쉽다.

# ✅ 개방-폐쇄 원칙(OCP)
**개방-폐쇄 원칙Open-Closed**은 **확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다**는 원칙이다.

> 아니.. 단일 책임 원칙에서는 수정하기 쉬워진다면서요? 변경에는 닫혀 있다니, 수정하지 말라는 건가요?

이 원칙은 모든 변경에 대해 말하는 게 아니다. 확장될 때의 변경을 말한다.

**기존의 코드를 변경하지 않으면서도 시스템의 기능을 확장할 수 있어야 한다.**
개방-폐쇄 원칙에 따르면, 새로운 기능을 추가할 때 기존의 코드에 영향을 주지 않고도 추가할 수 있어야 한다.

요지는, 이미 잘 돌아가던 기존 코드를 확장한다고 건들이지 말고 새로운 요구사항만 구현하라는 뜻이다.

이때 이용하기 좋은 것이 추상화와 인터페이스다. 예시 코드로 보자.

## 🪙 예시 코드
- 개방 폐쇄 원칙을 지키지 않은 경우
결제 시 고객이 지불해야 하는 가격을 알려야 한다.
```
public class Casher {
	// 가격 찾기
    public int getPrice(String menu) {
    	if(메뉴==아메리카노)
        	return 2000;
        else if(메뉴==카페라떼)
        	return 3000;
 		else if ...
    }
}
```
만약 여기에서 신메뉴 버블티가 추가된다면? else if()을 추가해야 할 것이다. 신메뉴로 확장되지만 기존 코드가 변경되는 것이다.

- 개방 폐쇄 원칙을 지킨 경우
메뉴가 몇 개가 추가되든 기존의 코드들은 변하지 않는다.
```
interface Drink {
	int getPrice();
}

class Americano {
	public int getPrice() { return 2000; }
}

class CafeLatte {
	public int getPrice() { return 3000; }
}

class BubbleTea {
	public int getPrice() { return 5000; }
}
```

개방-폐쇄 원칙은 유연하게 확장이 가능하면서도 기존 코드를 건드리지 않으므로 안정적이다.

# 🔑 요약

- 단일 책임 원칙
	- "클래스는 하나의 책임만 가져야 한다."
    - 하나의 클래스는 단 한가지의 이유로만 변경되어야 한다.
    - ✅ 유지보수 good: 코드 변경이 필요한 이유가 분리되고 명확하여 수정이 쉽다.
    - ✅ 재사용성 good: 각 클래스가 독립적이므로 나중에 해당 기능이 필요한 상황에서 쉽게 재사용이 가능하다.
    - ✅ 테스트 good: 한 가지 일을 잘하는지 테스트하면 되니 쉽다.
    
- 개방-폐쇄 원칙
	- "확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다."
    - ✅ 안정성 good: 기존 코드를 건드리지 않으니, 이미 잘 돌아가던 기능은 에러가 나지 않는다.
    - ✅ 유연성, 확장성 good: 새로운 기능을 쉽게 추가하기 편하다.
    - **추상화와 인터페이스**를 잘 활용하자!

# 블로그
[링크](https://velog.io/@soo7132/%EC%9C%84%ED%81%B4%EB%A6%AC-%ED%8E%98%EC%9D%B4%ED%8D%BC-2-1.-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-SOLID-%EC%9B%90%EC%B9%99-%EC%A4%91-%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99SRP%EA%B3%BC-%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99OCP)
