# Git Merge Vs Git Rebase

## Git Merge : 두 브랜치를 통합하여 하나로 합치는 작업을 수행

```bash
# feature 브랜치 -> master로 병합
git checkout main
git merge feature
```

- C1의 파생 브랜치인 Feature1 ( A, B, C )
- Main 브랜치 ( C0, C1, D, E )

→ Merge할 각 브랜치의 최신 노드를 병합한다.

→기존 브랜치 히스토리를 유지하며 새로운 커밋(Merge Commit)을 생성합니다. ( F )

### Merge 종류

### Fast-forward : **병합 대상 브랜치가 현재 브랜치의 후속(commit)인 경우 사용되는 병합 전략입니다.**

- 만약 **Main의 D, E 커밋이 없었고 C1 노드**와 C1노드에서 파생된 **Feature1 브랜치의 C**가 Merge된다면 병합 커밋을 생성하지 않고 브랜치를 단순히 앞으로 이동시켜 병합합니다.

---

### 3-way Merge: 두 브랜치가 공통 조상(commit)을 가지지만 서로 다른 변경 사항이 존재할 때 적용됩니다. 충돌이 일어나면 사용자가 수동으로 직접 해결한다.

- 위 사진의 내용으로 Main의 E 커밋과 Feature1의 C 커밋의 병합을 예시로 들 수 있고, 공통 조상은 C1 커밋이다. (공통 조상을 기준으로 변경 사항 비교)
- 충돌이 발생하면 사용자가 직접 코드를 수정하여 해결한다.
- **병합 커밋 (F) 가 항상 생긴다.**

---

### Squash and Merge : 병합할 브랜치에 있는 모든 커밋들을 하나의 커밋으로 만든 후, 기준이 되는 브랜치에 추가하는 방식으로 병합합니다.

- **여러 커밋을 하나로 압축**
    1. 병합 대상 브랜치의 모든 커밋을 하나의 커밋으로 "압축(Squash)"하여 병합합니다.
    2. 최종 커밋 메시지는 사용자가 수정하거나 브랜치의 모든 커밋 메시지를 포함할 수 있습니다.
- **직선형 히스토리 유지**
    1. 병합 커밋을 생성하지 않으며, 히스토리가 간결하게 정리됩니다.
- **원본 브랜치 히스토리 삭제**
    1. 병합 후 원본 브랜치의 개별 커밋 히스토리는 삭제되며, 최종 커밋만 저장소에 남습니다. → Commit 메시지가 복잡하지 않게 됨.

### **장점**

- 브랜치의 독립적인 작업 흐름과 히스토리를 그대로 보존합니다.
- 병합된 브랜치의 변경 사항을 쉽게 추적할 수 있습니다.

### **단점**

- 브랜치 간의 작업 히스토리가 복잡해질 수 있습니다(특히 병합 커밋이 많아질 경우).

## Git Rebase : 자신 브랜치의 베이스(base)를 다른 브랜치의 최신 상태 앞으로 재설정합니다.

```bash
# feature 브랜치를 master 브랜치 위로 재베이스
git checkout feature
git rebase main
# 충돌(conflict)이 발생하면 사용자가 해결 후
# git rebase --continue 명령으로 재베이스를 완료해야 합니다.
```


## ⬇️

![출처 : https://www.youtube.com/watch?v=0chZFIZLR_0](https://prod-files-secure.s3.us-west-2.amazonaws.com/af6d7ff7-4076-4e73-9399-1a77d41baf77/11fe767d-dd2d-4c73-ab8c-46f3d400d3da/image.png)

출처 : https://www.youtube.com/watch?v=0chZFIZLR_0

Feature1 브랜치에서 `git rebase main` 명령어 시 Main 브랜치 위로 Feature1 브랜치가 올라간다.

### **장점**

- 깔끔하고 일관된 히스토리를 유지할 수 있습니다.
- 병합 커밋 없이 변경 사항을 통합합니다.

### **단점**

- 히스토리를 재작성하기 때문에 이미 **공유된 브랜치**에서 사용하는 것은 위험할 수 있습니다.
- 협업 시 예상치 못한 문제가 발생할 가능성이 있습니다.

## Rebase의 황금 규칙

- "공유된 저장소에 이미 푸시된 커밋은 절대 Rebase 하지 말라.” → 누군가 푸시된 커밋을 가지고 개발 시 연쇄적인 충돌을 유도할 수 있다.

### **Rebase를 안전하게 사용하는 방법**

1. **로컬 브랜치에서만 Rebase 사용**
    - **공유되지 않은 개인 브랜치**에서만 Rebase를 사용하세요.
2. **공유 브랜치에서는 Rebase 금지**
    - Main과 같은 공유 브랜치에서는 Rebase를 피하고, 대신 `git merge`를 사용하세요.
3. **Rebase 전 팀과 소통**
    - 공유된 브랜치를 Rebase해야 한다면 팀원들에게 미리 알리고 강제 푸시로 인한 영향을 최소화하세요.

### **실수로 Rebase 후 강제 푸시했을 때 복구 방법**

1. **Git Reflog 확인**
    - `git reflog` 명령어로 Rebase 전 원래 커밋 해시를 찾습니다:
        
        ```bash
        git reflog
        ```
        
2. **브랜치를 원래 커밋으로 복구**
    
    ```bash
    git reset --hard <원래-커밋-해시>
    ```
    
3. **복구된 히스토리를 강제로 푸시**
    
    ```bash
    git push --force
    
    ```
    

## **1. `git pull`**

### **설명**

- **원격 저장소의 변경사항**을 가져오고, **자동으로 현재 브랜치에 병합**합니다.
- `git fetch` + `git merge`를 한 번에 수행합니다.

### **사용 시기**

- 로컬 브랜치를 최신 상태로 유지하기 위해 원격 저장소의 변경사항을 바로 적용하려는 경우 사용.

### **동작**

1. 원격 저장소의 최신 데이터를 가져옵니다.
2. 현재 체크아웃된 브랜치에 가져온 데이터를 **병합**합니다.

### 

---

## **2. `git fetch`**

### **설명**

- **원격 저장소의 변경사항**을 가져오지만, **병합은 하지 않습니다.**
- 데이터를 로컬 저장소에만 다운로드하며, 작업 브랜치에 적용하려면 추가 작업(`merge` 또는 `rebase`)이 필요합니다.

### **사용 시기**

- 병합 전 변경사항을 미리 확인하거나, 최신 상태를 유지하되 바로 병합하지 않으려는 경우 사용.

### **동작**

1. 원격 저장소의 최신 데이터를 가져옵
2. 변경사항은 로컬 저장소의 **원격 추적 브랜치(remote-tracking branch)**에 저장됩니다.
    - 예: `origin/main`

### 

---

## **주요 차이점**
## **주요 차이점**

| **구분** | **git pull** | **git fetch** |
| --- | --- | --- |
| **병합 여부** | 변경사항을 로컬 브랜치에 **자동 병합** | 변경사항을 가져오지만 **병합은 하지 않음** |
| **안전성** | 병합 중 충돌 가능성 있음 | 병합되지 않아 충돌 위험 없음 |
| **작업 대상** | 현재 체크아웃된 브랜치에만 적용 | 모든 원격 추적 브랜치의 변경사항을 가져옴 |
| **사용 목적** | 변경사항을 즉시 적용 | 변경사항을 확인 후 수동으로 병합하거나 작업 |
| **명령어 조합** | `fetch` + `merge` | `fetch`만 수행 |
