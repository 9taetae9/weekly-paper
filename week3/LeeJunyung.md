[Week 3 Topics]
###### 🇶 HashSet의 내부 동작 방식과 중복 제거 메커니즘을 설명하고, HashSet이 효율적인 중복 체크를 할 수 있는 이유를 설명해주세요.
###### 🇶 O(n)과 O(log n)의 성능 차이를 실생활 예시를 들어 설명하고, 데이터의 크기가 1백만 개일 때 각각 대략 몇 번의 연산이 필요한지 비교해주세요.
---
**🌟 "HashSet은 해시테블을 기반으로 동작하며, 내부적으로 HashMap을 사용하여 데이터를 관리한다"🌟**
먼저, Set은 중복원소를 허용하지 않는 데이터 자료구조이다. Hash는 임의의 길이를 갖는 데이터를 고정된 길이의 데이터로 변환(매핑)하는것을 말한다. 

### HashSet의 동작원리
ArrayList, LinkedList와 같은 자료구조의 경우 특정 값을 찾으려 할때 배열 또는 노드를 다 순회하면서 특정값을 찾는 방식으로 동작한다. 
<br> 하지만 HashSet에서 해시함수를 사용하여 동작하면 굳이 순회할 필요가 없다. 
- 동일한 값에 대해 동일한 다이제스트(해시함수에서 얻은 값)를 얻게 되기 때문이다. 이 특정 값에 대한 다이제스트는 변하지 않기 때문에 이 값을 배열의 위치(인덱스)로 활용하게 된다. 

또한, ArrayList, LinkedList와 같은 자료구조의 경우 원소를 add 할때마다 해당 원소가 중복인지 아닌지 검사해야 하는식으로 동작한다. 이때, 모든 원소를 검사하면서 진행한다면 매우 비효율적이다. 
- 이때, hash함수를 통해 특정값의 고유한 키 값 다이제스트를 얻고 그 값에 대응하는 인덱스를 찾아 해당 인덱스에 있는 요소만을 검사하면 된다.

즉, HashSet은 내부적으로 HashMap을 사용하여 데이터를 관리한다. 
HashSet에 값을 저장할 때 그 값을 HashMap의 키로 저장되는것이다. 

📍 HashSet의 add() 메소드는 값을 추가할 때 내부적으로 두가지 과정을 거친다. 
1. hashcode() : 객체의 해시코드를 생성해준다. 객체를 좀 더 효율적으로 비교하기 위해 사용한다. 
<br>즉, hashCode()를 호출하여 객체의 해시값을 계산한다. > 사용하지 않으면 객체가 주소를 가르키게 되기 때문에 꼭 오버라이딩 해줘야 한다.
2. equals() : 객체 간의 동등성을 비교한다. 즉, 이 메소드를 호출하여 해당 해시값의 슬롯에 이미 동일한 객체가 있는지를 확인하게 된다.

### HashSet의 중복제거 메커니즘
- HashSet은 각 객체의 해시코드를 사용해서 저장 위치를 결정하고, 동일한 해시코드가 두번 나오지 않도록 관리한다.
- equals() 메소드 사용으로 두 객체가 동일한 값을 가지는지 확인한다. 동일한 해시 코드의 객체가 추가될 때마다 equals() 메소드를 호출하여
  중복된 요소를 확인하고, 동일한 객체가 있는 경우 추가를 거부하도록 동작한다. 

