### HashSet의 내부 동작 방식과 중복 제거 메커니즘

### 내부 동작 방식

- **`HashSet`은 실제로 `HashMap` 객체를 사용하여 데이터를 저장하고 관리합니다.**
    - `HashSet`에 데이터를 추가하면, 내부적으로 `HashMap`의 키(key)로 해당 데이터를 저장합니다.
    - `HashMap`의 값(value)은 더미 값으로 사용되며, 이는 `HashSet`의 모든 요소가 고유하기 때문에 필요하지 않습니다.
    
    ```java
    private transient HashMap<E,Object> map;
    
    // Dummy value to associate with an Object in the backing Map
    private static final Object PRESENT = new Object();
    ```
    

### 2. **중복 제거 메커니즘**

- 중복 확인은 두 단계로 이루어집니다:
    1. **`hashCode()` 검사**: 동일한 해시 코드를 가진 데이터가 있는지 확인합니다.
    2. **`equals()` 검사**: 해시 코드가 동일한 경우, 객체의 내용이 실제로 같은지 `equals()` 메서드를 사용해 비교합니다. ( 오버라이딩이 이루어지지 않았을 시 객체 주소를 가지고 판단 )

### 3. **HashSet이 효율적인 중복 체크를 할 수 있는 이유**

- 해시 테이블의 기본적인 시간 복잡도는 데이터 삽입 및 검색 시 **O(1)**입니다.
- `hashCode()`와 `equals()`를 통해 중복 여부를 확인하므로, 데이터의 양이 많아도 빠르게 중복 검사를 수행할 수 있습니다.
- 단, 해시 충돌(hash collision)이 많아지면 성능이 저하될 수 있으며, 이 경우 시간 복잡도는 **O(n)**에 가까워질 수 있습니다.

### 예시

### **1. 저장된 형태**

`HashMap`의 저장 형태는 다음과 같이 **키와 값**을 매핑하여 관리합니다:

- **키**: 고유한 값으로, 데이터를 식별하는 데 사용됩니다.
- **값**: 키와 연결된 데이터.

예를 들어, `key1: value1`과 `key2: value2`를 저장하면 내부적으로 다음과 같은 엔트리들이 저장됩니다:

```scss

Entry(key1, value1)
Entry(key2, value2)

```

---

### **2. 해시맵의 내부 저장 방식**

`HashMap`은 **버킷(bucket)**이라는 배열을 기반으로 데이터를 저장합니다. 각 엔트리는 특정 버킷에 저장되며, 다음과 같은 데이터 구조를 가집니다:

```java
class Node<K, V> {
    final int hash;    // 해시 값
    final K key;       // 키
    V value;           // 값
    Node<K, V> next;   // 다음 노드 (체이닝용)
}

```

이 구조를 통해 해시 함수로 계산된 **해시 값(hash)**을 저장하고, 키와 값의 매핑 정보를 유지합니다.

---

### **3. 저장 프로세스**

- **입력 데이터**: `put(key, value)`
1. **해시 값 계산**:
    - 키에 대해 `hashCode()`를 호출하여 해시 값을 계산합니다.
    - 이 해시 값을 배열의 크기(버킷 수)로 나눠, 데이터가 저장될 인덱스를 결정합니다.
    index=hash(key)%capacity
        
        index=hash(key) % capacity\text{index} = \text{hash(key)} \, \% \, \text{capacity}
        
2. **버킷에 저장**:
    - 계산된 인덱스에 데이터(엔트리)를 저장합니다.
    - 해시 충돌이 발생하면, 해당 버킷에서 연결 리스트 또는 트리로 데이터를 관리합니다.

---

### **4. 검색 프로세스**

- **입력 데이터**: `get(key)`
1. **해시 값 계산**:
    - 검색하려는 키(`key`)에 대해 `hashCode()`를 호출하여 해시 값을 계산합니다.
2. **버킷 접근**:
    - 계산된 해시 값을 사용해 버킷(배열의 인덱스)에 접근합니다.
3. **키 비교**:
    - 같은 버킷에 저장된 데이터 중, `equals()`를 사용하여 키가 동일한지 확인합니다.
4. **값 반환**:
    - 키가 일치하는 엔트리의 값을 반환합니다.

---

### **5. 저장과 검색의 연결**

정리하면, 해시맵의 동작은 다음과 같은 흐름을 가집니다:

1. **저장 시**:
    - `hash(key)` → **해시 값** 계산 → 버킷(인덱스)에 저장.
    - 데이터는 `hash: key`로 매핑되어 쉽게 접근할 수 있도록 구성.
2. **검색 시**:
    - `hash(key)`로 **해시 값**을 계산하여 관련 버킷을 빠르게 찾음.
    - 해당 버킷에서 **equals()**를 통해 키를 비교하여 정확히 원하는 값을 반환.


# O(n)과 O(log n)의 성능 차이

---

## 1. O(n)과 O(log n)의 의미

### O(n): 선형 시간 복잡도
- 데이터의 크기 \( n \)에 비례하여 연산 시간이 증가합니다.
- **예**: 배열에서 특정 값을 찾기 위해 처음부터 끝까지 순차적으로 탐색하는 경우.

### O(log n): 로그 시간 복잡도
- 데이터 크기가 증가하더라도 연산 시간은 \( \log n \)에 비례하여 완만히 증가합니다.
- **예**: 정렬된 배열에서 이진 탐색(Binary Search)을 사용하여 값을 찾는 경우.

---

## 2. 실생활 예시

### O(n): 선형 탐색
- 책상 위에 무작위로 놓인 책들 중 특정 책을 찾는 과정.
- 데이터(책)의 수가 많아질수록 탐색 시간은 선형적으로 늘어납니다.

### O(log n): 이진 탐색
- 번호가 매겨진 정렬된 책장에서 특정 번호의 책을 찾는 과정.
- 책장의 중간을 기준으로 범위를 절반씩 줄여가며 탐색합니다.
- 데이터의 개수가 많아져도 탐색 횟수는 \( \log n \)에 비례하여 적게 증가합니다.

---

## 3. 1백만 개 데이터의 경우

| **시간 복잡도** | **설명**                                   | **연산 횟수**         |
|------------------|-------------------------------------------|-----------------------|
| **O(n)**         | 데이터를 모두 탐색해야 하므로 1,000,000번 | 1,000,000            |
| **O(log n)**     | 데이터 크기에 비례한 로그 계산            | \( \log_2(1,000,000) \approx 20 \) |

---
