# ✏️ Week 5 위클리 페이퍼
## 웹 서버(Web Server)와 WAS(Web Application Server)의 차이를 설명하고, Spring Boot의 내장 톰캣이 이 둘 중 어디에 해당하는지 설명해주세요

# 웹 서버(Web Server)

웹 서버는 클라이언트(웹 브라우저)로부터 HTTP 요청을 받아 요청에 맞는 응답 결과를 전송하는 역할을 한다.

![](https://velog.velcdn.com/images/soo7132/post/00ec7e78-982f-4796-b077-864b82558206/image.png)

## 작동 방식

클라이언트 URL을 입력하여 요청을 보내고, 이 URL이 웹 서버의 주소 식별자이다.

**클라이언트와 웹 서버의 통신 방식**
1. 클라이언트는 URL을 사용하여 서버의 IP 주소를 찾음.
2. 클라이언트는 원하는 정보를 위한 HTTP 요청을 보냄.
3. 웹 서버는 데이터베이스와 통신하여 관련 데이터를 찾음.
4. 웹 서버는 HTML 페이지, 이미지, 파일 등과 같은 정적 리소스를 HTTP 형태로 응답을 생성하여 클라이언트에게 반환함.
5. 응답 결과를 받은 클라이언트가 사용자에게 정보를 표시함.

✅ 이때 정적 리소스(정적 콘텐츠)란,
변경되지 않는 파일로, 사용자가 요청할 때마다 서버는 **동일한 데이터**를 반환한다.

예시로는 HTML 파일, CSS 스타일, JavaScript 파일, 이미지, 동영상 등이 있다.


# WAS(Web Application Server)

일반적인 서비스에서 정적인 콘텐츠만 제공해주는 경우는 잘 없다.
새로운 데이터가 필요한 경우가 있다.

만약, 사용자로부터 동적인 요청이 들어오면, 웹 서버에서 자체적으로 동적인 콘텐츠를 생성할 수 없기에 WAS에 요청한다.

WAS는 일반적으로 애플리케이션 서버라고도 부른다.
애플리케이션 서버는 웹 서버가 할 수 없는 동적 콘텐츠 생성, 애플리케이션 로직 및 다양한 리소스와의 통합을 지원하여 웹 서버의 기능을 확장한다.

## 작동 방식

1. 클라이언트에서 HTTP 요청을 보냄.
2. 웹 서버가 요청을 받음.
3. 정적 파일이면 웹 서버에서 그대로 제공하지만, 동적 콘텐츠인 경우 애플리케이션 서버로 요청을 전달함.
4. 애플리케이션 서버에서 요청을 분석하고 필요한 데이터를 조회하여 비즈니스 로직을 수행함.
5. 애플리케이션 서버는 새로운 HTML 페이지(또는 JSON) 등 생성한 응답을 웹 서버에 반환함.
6. 웹 서버는 클라이언트에 응답을 반환함.
7. 클라이언트가 사용자에게 정보를 표시함

✅ 동적 콘텐츠란,
사용자의 요청에 따라 그때그때 서버에서 생성되어 제공되는 콘텐츠를 말한다.

예시로 사용자별 맞춤 페이지나 인터넷 뉴스 최신 피드, 게시판 글 목록 등 늘 동일하지는 않은 데이터이다.

클라이언트에서 동일한 URL로 요청해도 사용자마자 다른 결과를 얻을 수 있다.

---

![](https://velog.velcdn.com/images/soo7132/post/348f36b1-ba7b-49d0-8850-6514bc2336e5/image.png)


_애플리케이션 서버는 클라이언트와 직접 소통하지 않는다._

늘 다음과 같은 방식으로 통신한다.



"애플리케이션 서버가 동적으로 생성 → 웹 서버가 클라이언트에게 전달"

그렇다면 애플리케이션 서버와 클라이언트 사이에 낀 웹 서버가 동적 콘텐츠를 전달하는 모양이니까
웹 서버가 동적 콘텐츠를 제공한다고 볼 수 있는 거 아닌가?라는 의문이 들 수도 있다.

애플리케이션이 동적으로 데이터를 생성하여도 "완성된 상태"로 클라이언트에 제공하면 더 이상 변하지 않는 고정된 상태가 된다. 
즉 최종적으로 클라이언트가 받는 것은 정적 콘텐츠이고, 웹 서버는 정적인 형태로 리소스를 제공한다.

# 🔑 웹 서버와 WAS의 차이점 요약


| 구분 | 웹 서버 (Web Server) | 애플리케이션 서버 (WAS) |
|------|------------------|------------------|
| **역할** | 정적 콘텐츠 제공 (HTML, CSS, JS, 이미지 등) | 동적 콘텐츠 처리 (비즈니스 로직, DB 연동) |
| **작동 방식** | HTTP 요청을 받아 정적 파일을 반환 | 비즈니스 로직 실행 후 HTML, JSON 등의 동적 데이터 생성 |
| **요청 처리 방식** | 클라이언트 요청을 받아 정적 파일 제공 또는 필요에 따라 WAS로 전달 | 웹 서버에서 전달받은 요청을 처리하고 응답 생성 |
| **클라이언트와의 관계** | 클라이언트와 직접 통신 | 보통 웹 서버를 통해서만 클라이언트와 통신 |
| **데이터 연동** | 없음 (파일만 제공) | 데이터베이스와 연동하여 동적 콘텐츠 생성 |
| **예시** | Apache, Nginx, IIS | Tomcat, JBoss, WebLogic, Flask, Express.js |

# + Tomcat은 어디에 해당할까?

![](https://velog.velcdn.com/images/soo7132/post/670c0d50-8a28-47e9-a168-11d68c14b6e6/image.png)

**Apache Tomcat**

톰캣은 Java 기반 웹 애플리케이션을 실행하는 오픈 소스 웹 컨테이너 및 WAS이다.

✅ 웹 컨테이너란?
 서블릿(Servlet)과 JSP(Java Server Pages)와 같은 Java 기반 웹 애플리케이션을 실행하는 환경으로, 서블릿을 실행하는 핵심 모듈이다.

❇️ 서블릿이란?
 Java 기반 웹 애플리케이션에서 HTTP 요청을 처리하고 동적 웹 페이지를 생성, 응답을 반환하는 클래스이다.

❇️ JSP란?
 JSP(Java Server Pages)는 서버 측에서 실행되는 HTML 페이지로, Java 코드를 HTML 안에 삽입하여 동적인 웹 페이지를 생성할 수 있게 해주는 기술이다.

즉, 톰캣은 서블릿과 JSP를 실행할 수 있는 서버로 Spring Boot의 내장 서버이기도 하다.

비즈니스 로직을 수행하고 동적인 콘텐츠를 생성할 수 있다는 점에서 톰캣은 WAS의 역할을 수행할 수 있다고 본다.

그러나 일반적인 WAS(예: JBoss, WebLogic 등)에서 가능한 트랜잭션 처리나 보안 기능 같은 추가 기능은 포함되어 있지 않아 웹 컨테이너라고 부르는 게 가장 적합하지 않을까?

# 참고자료

> [AWS: 웹 서버와 애플리케이션 서버의 차이점은 무엇인가요?](https://aws.amazon.com/ko/compare/the-difference-between-web-server-and-application-server/)
[웹 서버와 WAS](https://yozm.wishket.com/magazine/detail/1780/)
[[TOMCAT] 🐱 아파치 톰캣 개념 구성  & 설정 💯 정리](https://inpa.tistory.com/entry/TOMCAT-%E2%9A%99%EF%B8%8F-%EC%84%A4%EC%B9%98-%EC%84%A4%EC%A0%95-%EC%A0%95%EB%A6%AC#%ED%86%B0%EC%BA%A3_tomcat)


## Spring Boot에서 사용되는 다양한 Bean 등록 방법들에 대해 설명하고, 각각의 장단점을 비교하세요.

# ✅ Bean의 개념

Bean이란?
- 스프링 IoC 컨테이너에 의해 관리되는 객체

스프링에서는 개발자가 아닌 IoC 컨테이너에 의해 객체가 생성되고, 의존 관계가 관리되고, 필요 없는 객체가 소멸된다.

## Bean의 특징

### POJO(Plain Old Java Object)

- 특별한 규약에 얽매이지 않은 순수 자바 객체.
- 스프링 Bean은 대개 POJO 형태로 작성하여, 다른 프레임워크에 종속되지 않고 재사용성이 높다.

### 컨테이너 관리

- Bean은 IoC 컨테이너에 등록되어 관리된다.
- 등록된 Bean은 필요 시점에 컨테이너가 자동으로 의존성을 주입하고, 라이프사이클을 제어합니다.

### 의존성 역전(Inversion of Control)

- Bean은 자기 스스로가 의존성을 만들거나 관리하지 않고, 오직 자신의 로직에만 집중한다.
- 필요한 의존성(다른 Bean과의 관계)은 컨테이너가 주입해 준다.

### 배치(Assembly)와 설정(Configuration)

- Bean끼리의 관계(어떤 Bean이 어떤 Bean을 참조하는지 등)는 별도의 설정 파일(자바 설정, XML, 어노테이션 스캔 등)을 통해 정의한다.
- 덕분에 코드와 설정을 분리하여 **확장성과 유연성**을 극대화할 수 있다.

# ⚙️ 수동 등록: Configuration & Bean

```@Configuration``` 어노테이션이 붙은 클래스는 스프링 빈을 설정하는 클래스임을 나타낸다.

```
@Configuration
public class AppConfig {

	// 빈 등록
    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}
```

```@Bean``` 어노테이션을 사용해 특정 클래스를 빈으로 등록한다.
이 메소드(```myService()```)가 여러 번 호출되더라도 실제 인스턴스는 단 하나만 생성되도록, 즉 싱글톤이 보장되도록 처리한다.

@Bean은 주로 외부에서 만든(자신이 개발한 코드가 아닌 다른 사람이 개발한 코드) 클래스의 객체를 등록하기 위해 사용되는데,
외부 라이브러리 클래스의 객체 생성 메소드를 만든 후 해당 메소드의 선언하는 방식으로 사용한다.

이처럼 자바 클래스를 이용해 Bean을 정의하고 의존 관계를 설정하는 방법을
**Java Config**라고 한다.

## ✅ 장점

1. **타입 안전성(Type-safety)**
    - 기존의 설정 방법 XML은 문자열 기반이라 오타가 발생해도 컴파일 시점에 잡히기 어렵다.
    - 자바 코드로 작성되므로 IDE의 코드 자동 완성, 컴파일 타임 체크, 리팩토링 지원이 용이하다.
2. **간결성과 가독성**
    - 자바 클래스는 필요한 만큼만 선언하고, 로직에 가까운 방식으로 Bean 정의를 표현할 수 있다.
3. **유연한 구조**
    - 설정을 여러 자바 클래스로 모듈화해서 관리하기 쉽다.
    - 조건부 로직(if/else) 등을 자바 코드에서 바로 적용 가능하다. (예: 운영 환경/테스트 환경 분기)
    - 반면 XML 설정에도 **외부 설정 관리**, **배포 시점에 소스 코드 수정 없이 설정만 바꾸기** 등의 장점이 있으므로, 상황에 따라 혼합 사용되기도 한다.


# 📢 자동 등록: Annotation

## 어노테이션이란?

사전적으로는 '주석'이라는 의미로 소스 코드가 컴파일되거나 실행될 때 컴파일러 및 다른 프로그램에게 필요한 정보를 전달해 주는 문법 요소이다.

## @Component

@Bean과 달리 **직접 생성하는 클래스**를 스프링 빈으로 등록하기 위해 사용한다.
빈으로 등록하고 싶은 클래스에 ```@Component``` 어노테이션을 붙인다.

```
@Component
public class MyComponent {
    public void sayHello() {
        System.out.println("Hello from MyComponent!");
    }
}
```

위 예시에서 MyComponent 클래스는 @Component 애노테이션 덕분에 Spring 컨테이너에 Bean으로 등록된다.

---

@Componet를 기반으로 특수화된 어노테이션들이 있다.
자주 사용하는 대표적인 예시로 ```@Service```, ```@Controller```, ```@Repository```가 있다.

기능적으로는 @Component와 같이 클래스를 빈으로 등록하는 역할을 하지만 이름에서 알 수 있듯이 역할이 명확하게 구분이 되어 있다.
@Component는 일반적으로 모든 유형의 클래스에 사용될 수 있으며, **특정한 역할을 명시하지 않는다.**

- **@Service**: 주로 비즈니스 로직을 처리하는 서비스 계층의 클래스를 나타낸다.
- **@Controller**:  HTTP 요청을 처리하고, 응답을 반환하는 웹 계층을 담당하는 클래스를 나타낸다.
- **@Repository**: 데이터베이스와 상호작용하는 데이터 액세스 계층의 클래스를 나타낸다.


**@Service**, **@Controller**, **@Repository**는 모두 **@Component**의 특수화된 애노테이션으로, 기본적으로는 **@Component**와 같은 역할을 한다.

하지만 각 애노테이션은 특정 계층이나 역할을 명확히 표현하여
개발자에게 각 클래스의 의도를 명확히 알려주는 역할을 한다.

## ✅ 장점

1. **자동 등록의 편리함**
	- @Configuration 클래스를 따로 만들어 일일이 @Bean 메소드를 정의할 필요 없이 필요한 클래스에 어노테이션을 붙이면 Spring이 자동으로 클래스를 빈으로 등록해준다.
2. **코드 의도 전달 능력**
	- @Service, @Controller, @Repository 등 클래스의 역할을 명확히 구분할 수 있도록 한다.
    - 개발자가 코드의 의도를 쉽게 파악할 수 있게 직관적이다.
    

# 참고자료

> [[JAVA] 어노테이션 (Annotation)](https://developingman.tistory.com/41)
[@Bean vs @Component](https://jojoldu.tistory.com/27)

